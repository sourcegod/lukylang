Notes on Luky development in C++11
Date: vendredi, 26/06/2020
Author: Coolbrother
Last update: Sat, 29/08/2020
Last version: v0.29


  0. Changelog
# v0.29: nested multiline comments

# Version 0.28: Lambda Function

# Version 0.27: optimization 1

# Version 0.26: superclass

#--------------------------------------------------------------------------------

  1. Compile
1.1 
-- Using SConstruct file with scons script.
-- Release version:
g++ -std=c++11 -Wall -Wextra -pedantic -DNDEBUG *.cpp

-- Debug version:
With DEBUG option: -DDEBUG

-- Tracer version: 
with tracer option: -DTRACER

-- Gdb version:
with gdb option: -g

-- Passing to c++17 with:
std=c++17
to support "auto" deductible type for function, since C++14.

#--------------------------------------------------------------------------------

  2. Tools
2.1 
-- Using rlwrap tool to adding readline and history feature to REPL luky
interpreter.

#--------------------------------------------------------------------------------

  3. Bugs
3.1 FunctionStmt object 
# v0.26:
# FIX:
-- In the REPL, after declaring an user function,
cannot call this function, in a separate new line.
Works well, when calling this function in the same line, so in the same
interpreter instance.

#--------------------------------------------------------------------------------

  4. Best practice
4.1 include headers files
-- to avoid circular dependencies files,
make forward declarations in the header files,
and make definitions classes in the source (.cpp) files
and the include headers files.

4.2 Virtual functions
-- Apply the override specifier to every overrided virtual function you write.

4.3 Enum class 
-- It's better to define an enum class name, as a scoped enumeration instead of
the standard enumeration.
To avoid conflict between two enumerations in the same scope.

4.4 Template function
-- template function must be defining in the header file, 
not in the implementation file, because it's managed in compile time.

4.5 Constructors
-- For optimization, it's better to initialize variables in Initializer list.
It avoid to construct a new object when its initialized with assignment.
Exemple:
MyKlass(int a, int b) : m_a(a), m_b(b) {}

4.6 Destructor
-- To prevent destructor to be destroyed:
to prevent deleting pointer object by user, you can use the delete operator:
void operator delete(void *) = delete;
or to prevent the auto destructor for an object:
you can not defining a destructor: ~object();
or your can make the destructor private,
or in c++11, you can tell to the compiler do not provide a destructor deleted: ~object() = delete;
or make a "union" between base and derived object...
or create a smart pointer to this object.

4.7 Inused variables
-- You can comment in the argument name to avoid compiler warnings about inused
parameters.
Exemple:
void test(int a, int /*b*/) {}
-- Or you can make a macro or function template with empty body.
Exemple:
template <typename...T> void inused(T&&...) {}

#--------------------------------------------------------------------------------

  5. Release version
  
#--------------------------------------------------------------------------------

  6. Debug version
6.1 Logger object
-- We add logType function to print type of an object or variable using:
typeid(T).name() with including <typeinfo>.

-- Adding inused function for remove inused parameters compiler warnings .

6.2 In multiple objects
# v0.26:
-- Adding logMsg for debugging "this" keyword and "set" method for an instance.

-- Adding logMsg in constructors and destructor LukObject class.

# v0.27:
-- Adding logMsg in constructors and destructor Token class.


#--------------------------------------------------------------------------------
  7. Functions and classes
7.1 LukObject object
# v0.26:
-- Operators like equality operators, are non member functions
therefore there are declared friends
Also, for binary operators, object a is passing by copy not by reference
so the original object a stay unchanged
  
-- In resolve function:
# FIX: abstract class "Expr" cannot be in map
so, we store its uniq id in the map

-- In lukobject.hpp:
Adding getDynCast function, to convert base object to derived one,
using dynamic_pointer_cast.

# v0.27:
-- Adding static getNilPtr  function to return static nil object.

-- Adding static getStatNilPtr function to returning const statNilPtr variable.

-- Adding macro nilptr for getStatNilPtr function.
-- Adding copy constructor, copy assignment operator, move constructor, move
assignment operator to LukObject class.
-- Allmost returning ObjPtr type (shared_ptr lukobject), instead LukObject
type.

-- Passing TokPtr type (shared_ptr Token type), instead Token type.

-- Adding ostream operator<< for ObjPtr type.


7.2 Token object
# v0.27:
-- Adding TokPtr alias for shared_ptr Token type.

-- Adding ostream operator<< function for TokPtr type.

-- Adding uniq id to the Token class.


7.3 LukError object
# v0.27:
-- Passing TokPtr type to error function.


7.4 Scanner object
# v0.27:
-- Construct TokPtr type for Token class, instead simple Token class.

-- scanTokens function returns a vector of TokPtr token type.

# v0.28:
...

# v0.29: Nested multiline comments
-- Adding skipComments and skipMultiComments functions in the Scanner class.
-- Reordered functions and renamed global variables.


7.5 Parser object
# v0.27:
-- Most functions return TokPtr Token type, instead Token class.
Manage vector of TokPtr token type, instead vector of token class.

# v0.28:
-- Adding lambda parsing in the primary function.


7.6 AstPrinter object
# v0.27:
...


7.7 Interpreter object
# v0.26:
-- In interpret function:
When catching error, passing exception by reference to avoid copy

--  In executeBlock function:
Using catch(...) to catch all exceptions, even the Return exception.
-- In visitIfStmt function:
Not moving statement pointer, 
like: execute(std::move(stmt.thenBranch));
because it will be necessary later, for function call

-- In getexpr function
shared_ptr.get() returns the stored pointer, not the managed pointer.
and *shared_ptr dereference the smart pointer

-- We add logState for debugging globals and locals environment.

-- In logState function:
We make  a looping pattern, over the map values in environment object.

# v0.27:
-- Most visitExpr functions return ObjPtr type instead  LukObject class.

-- Most functions return the macro nilptr for nil object instead  lukobject
nil.

# v0.28: Lambda function
-- Adding visitFunctionExpr function for interpret lambda function.


7.8 Environment object
# v0.26:
-- We add getValues function to copy m_values to looping over it in the
interpreter.

-- In getValues function:
We use "auto" to make a deductible type for this function.
"auto" for function is only available since C++14 and C++17.

# v0.27:
-- Passing TokPtr token type, instead Token class.

-- Most functions return TokPtr token type, instead Token class.


7.9 Expr object
# v0.27:
-- Most visitExpr functions take and return ObjPtr type, instead lukobject
type.

-- All getName functions returning TokPtr type, instead Token type.

# v0.28: Lambda function
-- Adding FunctionExpr class in Expr class.

7.10 Stmt object
# v0.27:
-- Most visitStmt functions take TokPtr type as argument,
instead Token type.

# v0.28: Lambda function
-- Changing FunctionStmt constructor to add FunctionExpr as parameter.

7.11 RuntimeError object
# v0.27:
-- Taking TokPtr type instead Token type as argument.


7.12 LukCallable object
# v0.27:
-- The virtual call function  return ObjPtr type instead LukObject type.


7.13 ClockFunc object
# v0.27:
-- The virtual call function  return ObjPtr type instead LukObject type.


7.14 LukFunction object
# v0.26:
-- In call function: 
C++11 can only store polymorphic or derived class with pointers or smart
pointers in container like vector or unordered_map.
Otherwise, derived object will be slicing.
It took me more one month to realize this, and fixe this bug in LukFunction
object.


-- WARNING: cannot copy assignment derived object like FunctionStmt ..
so passing it by raw pointer.

# v0.27:
-- The virtual call function  return ObjPtr type instead LukObject type.

-- Most functions take and return ObjPtr type, instead lukobject
type.

# v0.28: Lambda function
-- Changing LukFunction constructor to add FunctionExpr as parameter.

7.15 Return object
# v0.27:
-- Taking ObjPtr type instead LukObject type as argument.


7.16 Jump object
# v0.27:
-- Taking TokPtr type instead Token type as argument.


7.17 Resolver object
# v0.27:
-- Most visitExpr functions take and return ObjPtr type, instead lukobject
type.
...


# v0.28: Lambda function
-- Adding visitFunctionExpr function.

7.18 Logger object
# v0.27:
-- Taking TokPtr type instead Token type as argument.


7.19 LukClass object 
# v0.26:
-- In call function:
"this" is a const pointer, so the current function should be not const
otherwire "this" is casting to const type* const
so not compile, when passing it as parameter to lukinstance object.

# v0.27:
-- The virtual call function  return ObjPtr type instead LukObject type.

-- Most functions take and return ObjPtr type, instead lukobject
type.


7.20 LukInstance object
# v0.26:
-- In get function
diff ways to convert raw pointer to shared_ptr pointer
here deep copy is necessary cause, this object is more sophiscated object,
so the default copy constructor not suficient.
std::shared_ptr<LukInstance> instPtr = std::make_shared<LukInstance>(*this);
or you can directly bind shared_ptr to "this", like:
std::shared_ptr<LukInstance> instPtr(this);
but you will face with error: double free corruption (out)
bad solution:
you can create a new shared_ptr in the .hpp file, or in global scope,
an associate it to the shared_ptr nearly created:
shared_ptr p_instance; // in the global scope
then:
p_instance = instPtr;
so, instPtr.use_count() =2
so the compiler will never try to delete this pointer.
-- In get function
to get derived object from shared_ptr base object
yout can use: 
static_pointer_cast or 
dynamic_pointer_cast to cast it.

-- In the copy constructor:
Make a deep copy for itself.
We should do a deep copy for this object
cause this object is more sophisticated
so the compiler default copy constructor cannot copy it entirely.

-- Adding getKlass and getFields functions
to copy m_klass and m_fields in another instance of lukinstance object.

# v0.27:
-- The get function Taking TokPtr type instead Token type as argument,
and returning ObjPtr type instead LukObject type.

-- The set function take TokPtr and ObjPtr type as argument.


7.21 Common object
# v0.28: Lambda function
-- Adding common file to regroup all aliases types.

  7.22

#--------------------------------------------------------------------------------

  8. Misc
8.1 Examples directory
# v0.27:
-- Adding example files to the examples directory.

# v0.28: Lambda function
-- Adding lambda file to the examples directory.

# v0.29: Nested multiline comments 
-- Adding multiline_comments file in examples directory.

8.2 Tests directory
# v0.27:
-- Adding tests files to the tests directory.

# v0.28: Lambda function
-- Adding lambda file to the tests directory.

# v0.29: Nested multiline comments 
-- Adding multiline_comments file in tests directory.


8.3 Notes directory
# v0.27:
-- Adding grammar  file to the notes directory.

# v0.28: Lambda function
-- Adding grammar file for lambda rule.

#--------------------------------------------------------------------------------
