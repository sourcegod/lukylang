Notes on Luky development in C++11
Date: vendredi, 26/06/2020
Author: Coolbrother
Last update: Sat, 27/06/2020

  1. Compile
1.1 
-- Using SConstruct file with scons script.
-- Release version:
g++ -std=c++11 -Wall -Wextra -pedantic -DNDEBUG *.cpp

-- Debug version:
With DEBUG option: -DDEBUG

-- Tracer version: 
with tracer option: -DTRACER

-- Gdb version:
with gdb option: -g

-- Passing to c++17 with:
std=c++17
to support "auto" deductible type for function, since C++14.

  2. Tools
2.1 
-- Using rlwrap tool to adding readline and history feature to REPL luky
interpreter.

  3. Bugs
3.1 
-- In the REPL, after declaring an user function,
cannot call this function, in a separate new line.
Works well, when calling this function in the same line, so in the same
interpreter instance.

  4. Best practice
4.1 include headers files
-- to avoid circular dependencies files,
make forward declarations in the header files,
and make definitions classes in the source (.cpp) files
and the include headers files.

4.2 Virtual functions
-- Apply the override specifier to every overrided virtual function you write.

4.3 Enum class 
-- It's better to define an enum class name, as a scoped enumeration instead of
the standard enumeration.
To avoid conflict between two enumerations in the same scope.

  5. Release version
  
  6. Debug version
6.1 Logger object
-- We add logType function to print type of an object or variable using:
typeid(T).name() with including <typeinfo>.
6.2 In multiple objects
-- Adding logMsg for debugging "this" keyword and "set" method for an instance.



  7. Functions and classes
7.1  Lukfunction object
-- In call function: 
C++11 can only store polymorphic or derived class with pointers or smart
pointers in container like vector or unordered_map.
Otherwise, derived object will be slicing.
It took me more one month to realize this, and fixe this bug in LukFunction
object.

7.2 lukclass object 
-- In call function:
"this" is a const pointer, so the current function should be not const
otherwire "this" is casting to const type* const
so not compile, when passing it as parameter to lukinstance object.

7.3 Interpreter object
-- In interpret function:
When catching error, passing exception by reference to avoid copy

--  In executeBlock function:
Using catch(...) to catch all exceptions, even the Return exception.
-- In visitIfStmt function:
Not moving statement pointer, 
like: execute(std::move(stmt.thenBranch));
because it will be necessary later, for function call

-- In getexpr function
shared_ptr.get() returns the stored pointer, not the managed pointer.
and *shared_ptr dereference the smart pointer

-- We add logState for debugging globals and locals environment.

-- In logState function:
We make  a looping pattern, over the map values in environment object.


7.4 Lukobject object
-- Operators like equality operators, are non member functions
therefore there are declared friends
Also, for binary operators, object a is passing by copy not by reference
so the original object a stay unchanged
  
-- In resolve function:
FIX: abstract class "Expr" cannot be in map
so, we store its uniq id in the map

7.5 Lukfunction object
-- WARNING: cannot copy assignment derived object like FunctionStmt ..
so passing it by raw pointer.

7.6 LukInstance object
-- In get function
diff ways to convert raw pointer to shared_ptr pointer
here deep copy is necessary cause, this object is more sophiscated object,
so the default copy constructor not suficient.
std::shared_ptr<LukInstance> instPtr = std::make_shared<LukInstance>(*this);
or you can directly bind shared_ptr to "this", like:
std::shared_ptr<LukInstance> instPtr(this);
but you will face with error: double free corruption (out)
bad solution:
you can create a new shared_ptr in the .hpp file, or in global scope,
an associate it to the shared_ptr nearly created:
shared_ptr p_instance; // in the global scope
then:
p_instance = instPtr;
so, instPtr.use_count() =2
so the compiler will never try to delete this pointer.
-- In get function
to get derived object from shared_ptr base object
yout can use: 
static_pointer_cast or 
dynamic_pointer_cast to cast it.

-- In the copy constructor:
Make a deep copy for itself.
We should do a deep copy for this object
cause this object is more sophisticated
so the compiler default copy constructor cannot copy it entirely.

-- Adding getKlass and getFields functions
to copy m_klass and m_fields in another instance of lukinstance object.


7.7 Environment object
-- We add getValues function to copy m_values to looping over it in the
interpreter.

-- In getValues function:
We use "auto" to make a deductible type for this function.
"auto" for function is only available since C++14 and C++17.


